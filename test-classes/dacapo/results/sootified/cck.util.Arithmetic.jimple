public class cck.util.Arithmetic extends java.lang.Object
{
    private static final int[] reverseKey;
    private static final int[] bitcountKey;
    static final boolean $assertionsDisabled;

    static void <clinit>()
    {
        java.lang.Class $stack3;
        boolean $stack4, l2#1;
        int[] $stack7, $stack58;

        $stack3 = class "Lcck/util/Arithmetic;";

        $stack4 = virtualinvoke $stack3.<java.lang.Class: boolean desiredAssertionStatus()>();

        if $stack4 != 0 goto label1;

        l2#1 = 1;

        goto label2;

     label1:
        l2#1 = 0;

     label2:
        <cck.util.Arithmetic: boolean $assertionsDisabled> = l2#1;

        $stack7 = newarray (int)[16];

        $stack7[0] = 0;

        $stack7[1] = 8;

        $stack7[2] = 4;

        $stack7[3] = 12;

        $stack7[4] = 2;

        $stack7[5] = 10;

        $stack7[6] = 6;

        $stack7[7] = 14;

        $stack7[8] = 1;

        $stack7[9] = 9;

        $stack7[10] = 5;

        $stack7[11] = 13;

        $stack7[12] = 3;

        $stack7[13] = 11;

        $stack7[14] = 7;

        $stack7[15] = 15;

        <cck.util.Arithmetic: int[] reverseKey> = $stack7;

        $stack58 = newarray (int)[16];

        $stack58[0] = 0;

        $stack58[1] = 1;

        $stack58[2] = 1;

        $stack58[3] = 2;

        $stack58[4] = 1;

        $stack58[5] = 2;

        $stack58[6] = 2;

        $stack58[7] = 3;

        $stack58[8] = 1;

        $stack58[9] = 2;

        $stack58[10] = 2;

        $stack58[11] = 3;

        $stack58[12] = 2;

        $stack58[13] = 3;

        $stack58[14] = 3;

        $stack58[15] = 4;

        <cck.util.Arithmetic: int[] bitcountKey> = $stack58;

        return;
    }

    public void <init>()
    {
        cck.util.Arithmetic l0;

        l0 := @this: cck.util.Arithmetic;

        specialinvoke l0.<java.lang.Object: void <init>()>();

        return;
    }

    public static int bitCount(byte)
    {
        byte l0;
        int $stack1, $stack3, $stack4, $stack6, $stack7, $stack8;
        int[] $stack2, $stack5;

        l0 := @parameter0: byte;

        $stack2 = <cck.util.Arithmetic: int[] bitcountKey>;

        $stack1 = l0 & 15;

        $stack7 = $stack2[$stack1];

        $stack5 = <cck.util.Arithmetic: int[] bitcountKey>;

        $stack3 = l0 >> 4;

        $stack4 = $stack3 & 15;

        $stack6 = $stack5[$stack4];

        $stack8 = $stack7 + $stack6;

        return $stack8;
    }

    public static byte clearBit(byte, int)
    {
        byte l0, $stack5;
        int l1, $stack2, $stack3, $stack4;

        l0 := @parameter0: byte;

        l1 := @parameter1: int;

        $stack2 = 1 << l1;

        $stack3 = $stack2 ^ -1;

        $stack4 = l0 & $stack3;

        $stack5 = (byte) $stack4;

        return $stack5;
    }

    public static boolean getBit(byte, int)
    {
        byte l0;
        int l1, $stack3, $stack4;
        boolean l2#1;

        l0 := @parameter0: byte;

        l1 := @parameter1: int;

        $stack3 = 1 << l1;

        $stack4 = l0 & $stack3;

        if $stack4 == 0 goto label1;

        l2#1 = 1;

        goto label2;

     label1:
        l2#1 = 0;

     label2:
        return l2#1;
    }

    public static boolean getBit(long, int)
    {
        long l0, $stack4, $stack5;
        int l2;
        byte $stack6;
        boolean l3#1;

        l0 := @parameter0: long;

        l2 := @parameter1: int;

        $stack4 = 1L << l2;

        $stack5 = l0 & $stack4;

        $stack6 = $stack5 cmp 0L;

        if $stack6 == 0 goto label1;

        l3#1 = 1;

        goto label2;

     label1:
        l3#1 = 0;

     label2:
        return l3#1;
    }

    public static boolean getBit(int, int)
    {
        int l0, l1, $stack3, $stack4;
        boolean l2#1;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        $stack3 = 1 << l1;

        $stack4 = l0 & $stack3;

        if $stack4 == 0 goto label1;

        l2#1 = 1;

        goto label2;

     label1:
        l2#1 = 0;

     label2:
        return l2#1;
    }

    public static int getBitField(int, int[])
    {
        int[] l1;
        int $stack4, l0, $stack5, l2#1, l3#2;
        boolean $stack6;

        l0 := @parameter0: int;

        l1 := @parameter1: int[];

        l2#1 = 0;

        l3#2 = 0;

     label1:
        $stack4 = lengthof l1;

        if l3#2 >= $stack4 goto label3;

        l2#1 = l2#1 << 1;

        $stack5 = l1[l3#2];

        $stack6 = staticinvoke <cck.util.Arithmetic: boolean getBit(int,int)>(l0, $stack5);

        if $stack6 == 0 goto label2;

        l2#1 = l2#1 | 1;

     label2:
        l3#2 = l3#2 + 1;

        goto label1;

     label3:
        return l2#1;
    }

    public static int getBitField(int, int, int)
    {
        int l0, l1, l2, $stack3, $stack4, $stack5, $stack6;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        l2 := @parameter2: int;

        $stack5 = l0 >> l1;

        $stack3 = 32 - l2;

        $stack4 = -1 >>> $stack3;

        $stack6 = $stack5 & $stack4;

        return $stack6;
    }

    public static int getBitMask(int)
    {
        int l0, $stack1, $stack2, $stack3;

        l0 := @parameter0: int;

        $stack1 = l0 - 1;

        $stack2 = 31 - $stack1;

        $stack3 = -1 >>> $stack2;

        return $stack3;
    }

    public static int getBitRangeMask(int, int)
    {
        int l1, l0, $stack2, $stack3, $stack4, $stack5;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        $stack2 = l1 - l0;

        $stack3 = 31 - $stack2;

        $stack4 = -1 >>> $stack3;

        $stack5 = $stack4 << l0;

        return $stack5;
    }

    public static int getInverseBitRangeMask(int, int)
    {
        int l0, l1, $stack2, $stack3;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        $stack2 = staticinvoke <cck.util.Arithmetic: int getBitRangeMask(int,int)>(l0, l1);

        $stack3 = $stack2 ^ -1;

        return $stack3;
    }

    public static long getLongBitRangeMask(int, int)
    {
        int l1, l0, $stack2, $stack3;
        long $stack4, $stack5;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        $stack2 = l1 - l0;

        $stack3 = 63 - $stack2;

        $stack4 = -1L >>> $stack3;

        $stack5 = $stack4 << l0;

        return $stack5;
    }

    public static int getSingleBitMask(int)
    {
        int l0, $stack1;

        l0 := @parameter0: int;

        $stack1 = 1 << l0;

        return $stack1;
    }

    public static int getSingleInverseBitMask(int)
    {
        int l0, $stack1, $stack2;

        l0 := @parameter0: int;

        $stack1 = 1 << l0;

        $stack2 = $stack1 ^ -1;

        return $stack2;
    }

    public static byte high(short)
    {
        short l0;
        int $stack1;
        byte $stack2;

        l0 := @parameter0: short;

        $stack1 = l0 >> 8;

        $stack2 = (byte) $stack1;

        return $stack2;
    }

    public static byte high(int)
    {
        int l0, $stack1, $stack2;
        byte $stack3;

        l0 := @parameter0: int;

        $stack1 = l0 & 65280;

        $stack2 = $stack1 >> 8;

        $stack3 = (byte) $stack2;

        return $stack3;
    }

    public static int highestBit(int)
    {
        int $stack3, $stack4, $stack5, $stack6, $stack7, l0#1, l1#2, l2#3;

        l0#1 := @parameter0: int;

        l1#2 = 31;

        $stack3 = l0#1 & -65536;

        if $stack3 != 0 goto label1;

        l1#2 = 31 + -16;

        l0#1 = l0#1 << 16;

     label1:
        $stack4 = l0#1 & -16777216;

        if $stack4 != 0 goto label2;

        l1#2 = l1#2 + -8;

        l0#1 = l0#1 << 8;

     label2:
        $stack5 = l0#1 & -268435456;

        if $stack5 != 0 goto label3;

        l1#2 = l1#2 + -4;

        l0#1 = l0#1 << 4;

     label3:
        $stack6 = l0#1 & -1073741824;

        if $stack6 != 0 goto label4;

        l1#2 = l1#2 + -2;

        l0#1 = l0#1 << 2;

     label4:
        $stack7 = l0#1 & -2147483648;

        if $stack7 != 0 goto label5;

        l1#2 = l1#2 + -1;

        l0#1 = l0#1 << 1;

     label5:
        if l0#1 != 0 goto label6;

        l2#3 = -1;

        goto label7;

     label6:
        l2#3 = l1#2;

     label7:
        return l2#3;
    }

    public static void inc(long[], int[], int)
    {
        boolean $stack4;
        int l2, $stack8, $stack14, $stack15, $stack16, l3#1, $stack5#6;
        long[] l0;
        long $stack6, $stack7, $stack9, $stack10;
        int[] l1;
        byte $stack11;
        java.lang.AssertionError $stack18;

        l0 := @parameter0: long[];

        l1 := @parameter1: int[];

        l2 := @parameter2: int;

        $stack4 = <cck.util.Arithmetic: boolean $assertionsDisabled>;

        if $stack4 != 0 goto label1;

        $stack14 = lengthof l0;

        $stack16 = $stack14 - 1;

        $stack15 = lengthof l1;

        if $stack16 == $stack15 goto label1;

        $stack18 = new java.lang.AssertionError;

        specialinvoke $stack18.<java.lang.AssertionError: void <init>()>();

        throw $stack18;

     label1:
        l3#1 = l2;

     label2:
        $stack5#6 = lengthof l0;

        if l3#1 >= $stack5#6 goto label4;

        $stack6 = l0[l3#1];

        $stack7 = $stack6 + 1L;

        l0[l3#1] = $stack7;

        $stack10 = l0[l3#1];

        $stack8 = l1[l3#1];

        $stack9 = (long) $stack8;

        $stack11 = $stack10 cmp $stack9;

        if $stack11 >= 0 goto label3;

        goto label4;

     label3:
        l3#1 = l3#1 + 1;

        goto label2;

     label4:
        return;
    }

    public static int log(int)
    {
        int l0, $stack1, $stack3, $stack4;

        l0 := @parameter0: int;

        if l0 != 0 goto label1;

        return 0;

     label1:
        $stack1 = l0 - 1;

        $stack3 = staticinvoke <cck.util.Arithmetic: int highestBit(int)>($stack1);

        $stack4 = 1 + $stack3;

        return $stack4;
    }

    public static byte low(short)
    {
        short l0;
        byte $stack1;

        l0 := @parameter0: short;

        $stack1 = (byte) l0;

        return $stack1;
    }

    public static byte low(int)
    {
        int l0;
        byte $stack1;

        l0 := @parameter0: int;

        $stack1 = (byte) l0;

        return $stack1;
    }

    public static int lowestBit(long)
    {
        int $stack4, l2#2, l3#3;
        long $stack5, $stack7, $stack9, $stack11, $stack13, l0#1;
        byte $stack6, $stack8, $stack10, $stack12, $stack14, $stack15;

        l0#1 := @parameter0: long;

        l2#2 = 0;

        $stack4 = (int) l0#1;

        if $stack4 != 0 goto label1;

        l2#2 = 0 + 32;

        l0#1 = l0#1 >> 32;

     label1:
        $stack5 = l0#1 & 65535L;

        $stack6 = $stack5 cmp 0L;

        if $stack6 != 0 goto label2;

        l2#2 = l2#2 + 16;

        l0#1 = l0#1 >> 16;

     label2:
        $stack7 = l0#1 & 255L;

        $stack8 = $stack7 cmp 0L;

        if $stack8 != 0 goto label3;

        l2#2 = l2#2 + 8;

        l0#1 = l0#1 >> 8;

     label3:
        $stack9 = l0#1 & 15L;

        $stack10 = $stack9 cmp 0L;

        if $stack10 != 0 goto label4;

        l2#2 = l2#2 + 4;

        l0#1 = l0#1 >> 4;

     label4:
        $stack11 = l0#1 & 3L;

        $stack12 = $stack11 cmp 0L;

        if $stack12 != 0 goto label5;

        l2#2 = l2#2 + 2;

        l0#1 = l0#1 >> 2;

     label5:
        $stack13 = l0#1 & 1L;

        $stack14 = $stack13 cmp 0L;

        if $stack14 != 0 goto label6;

        l2#2 = l2#2 + 1;

        l0#1 = l0#1 >> 1;

     label6:
        $stack15 = l0#1 cmp 0L;

        if $stack15 != 0 goto label7;

        l3#3 = -1;

        goto label8;

     label7:
        l3#3 = l2#2;

     label8:
        return l3#3;
    }

    public static int max(int, int)
    {
        int l0, l1, l2#1;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        if l0 <= l1 goto label1;

        l2#1 = l0;

        goto label2;

     label1:
        l2#1 = l1;

     label2:
        return l2#1;
    }

    public static int min(int, int)
    {
        int l0, l1, l2#1;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        if l0 >= l1 goto label1;

        l2#1 = l0;

        goto label2;

     label1:
        l2#1 = l1;

     label2:
        return l2#1;
    }

    public static long[] modulus(long, int[])
    {
        int[] l2;
        int $stack7, $stack8, $stack9, $stack10, $stack12, l6#2;
        long[] l3;
        long l4, $stack11, $stack13, l0#1;

        l0#1 := @parameter0: long;

        l2 := @parameter1: int[];

        $stack7 = lengthof l2;

        $stack8 = $stack7 + 1;

        l3 = newarray (long)[$stack8];

        $stack9 = lengthof l2;

        l6#2 = $stack9 - 1;

     label1:
        if l6#2 < 0 goto label2;

        $stack10 = l2[l6#2];

        l4 = (long) $stack10;

        $stack12 = l6#2 + 1;

        $stack11 = l0#1 % l4;

        l3[$stack12] = $stack11;

        $stack13 = (long) $stack10;

        l0#1 = l0#1 / $stack13;

        l6#2 = l6#2 + -1;

        goto label1;

     label2:
        l3[0] = l0#1;

        return l3;
    }

    public static long mult(long[], int[])
    {
        boolean $stack6;
        long[] l0;
        int $stack9, $stack10, $stack18, $stack22, $stack23, $stack24, l4#2, l5#3, $stack7#8, $stack8#12;
        long $stack11, $stack12, $stack13, $stack14, $stack15, $stack16, $stack17, l2#1;
        int[] l1;
        java.lang.AssertionError $stack26;

        l0 := @parameter0: long[];

        l1 := @parameter1: int[];

        l2#1 = 0L;

        l4#2 = 1;

        $stack6 = <cck.util.Arithmetic: boolean $assertionsDisabled>;

        if $stack6 != 0 goto label1;

        $stack22 = lengthof l0;

        $stack24 = $stack22 - 1;

        $stack23 = lengthof l1;

        if $stack24 == $stack23 goto label1;

        $stack26 = new java.lang.AssertionError;

        specialinvoke $stack26.<java.lang.AssertionError: void <init>()>();

        throw $stack26;

     label1:
        l5#3 = 0;

     label2:
        $stack7#8 = lengthof l0;

        $stack8#12 = $stack7#8 - 1;

        if l5#3 >= $stack8#12 goto label3;

        $stack16 = l0[l5#3];

        $stack15 = (long) l4#2;

        $stack17 = $stack16 * $stack15;

        l2#1 = l2#1 + $stack17;

        $stack18 = l1[l5#3];

        l4#2 = l4#2 * $stack18;

        l5#3 = l5#3 + 1;

        goto label2;

     label3:
        $stack9 = lengthof l0;

        $stack10 = $stack9 - 1;

        $stack12 = l0[$stack10];

        $stack11 = (long) l4#2;

        $stack13 = $stack12 * $stack11;

        $stack14 = l2#1 + $stack13;

        return $stack14;
    }

    public static byte packBits(int, int, int, int, int, int, int, int)
    {
        int l7, l6, l5, l4, l3, l2, l1, l0, $stack22, $stack28, $stack32, $stack36, $stack40, $stack44, $stack48;
        byte $stack23, l14#1, l15#2, l16#3, l17#4, l18#5, l19#6, l20#7;
        short l21#8;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        l2 := @parameter2: int;

        l3 := @parameter3: int;

        l4 := @parameter4: int;

        l5 := @parameter5: int;

        l6 := @parameter6: int;

        l7 := @parameter7: int;

        if l7 <= 0 goto label01;

        l14#1 = 1;

        goto label02;

     label01:
        l14#1 = 0;

     label02:
        if l6 <= 0 goto label03;

        l15#2 = 2;

        goto label04;

     label03:
        l15#2 = 0;

     label04:
        $stack48 = l14#1 | l15#2;

        if l5 <= 0 goto label05;

        l16#3 = 4;

        goto label06;

     label05:
        l16#3 = 0;

     label06:
        $stack44 = $stack48 | l16#3;

        if l4 <= 0 goto label07;

        l17#4 = 8;

        goto label08;

     label07:
        l17#4 = 0;

     label08:
        $stack40 = $stack44 | l17#4;

        if l3 <= 0 goto label09;

        l18#5 = 16;

        goto label10;

     label09:
        l18#5 = 0;

     label10:
        $stack36 = $stack40 | l18#5;

        if l2 <= 0 goto label11;

        l19#6 = 32;

        goto label12;

     label11:
        l19#6 = 0;

     label12:
        $stack32 = $stack36 | l19#6;

        if l1 <= 0 goto label13;

        l20#7 = 64;

        goto label14;

     label13:
        l20#7 = 0;

     label14:
        $stack28 = $stack32 | l20#7;

        if l0 <= 0 goto label15;

        l21#8 = 128;

        goto label16;

     label15:
        l21#8 = 0;

     label16:
        $stack22 = $stack28 | l21#8;

        $stack23 = (byte) $stack22;

        return $stack23;
    }

    public static byte reverseBits(byte)
    {
        byte l0, $stack10;
        int $stack1, $stack3, $stack4, $stack5, $stack7, $stack8, $stack9;
        int[] $stack2, $stack6;

        l0 := @parameter0: byte;

        $stack2 = <cck.util.Arithmetic: int[] reverseKey>;

        $stack1 = l0 & 15;

        $stack3 = $stack2[$stack1];

        $stack8 = $stack3 << 4;

        $stack6 = <cck.util.Arithmetic: int[] reverseKey>;

        $stack4 = l0 >> 4;

        $stack5 = $stack4 & 15;

        $stack7 = $stack6[$stack5];

        $stack9 = $stack8 | $stack7;

        $stack10 = (byte) $stack9;

        return $stack10;
    }

    public static int roundup(int, int)
    {
        int l0, l1, $stack2, $stack3, $stack4;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        $stack2 = l0 + l1;

        $stack3 = $stack2 - 1;

        $stack4 = $stack3 / 8;

        return $stack4;
    }

    public static byte setBit(byte, int)
    {
        byte l0, $stack4;
        int l1, $stack2, $stack3;

        l0 := @parameter0: byte;

        l1 := @parameter1: int;

        $stack2 = 1 << l1;

        $stack3 = l0 | $stack2;

        $stack4 = (byte) $stack3;

        return $stack4;
    }

    public static byte setBit(byte, int, boolean)
    {
        boolean l2;
        byte l0, $stack3, $stack4;
        int l1;

        l0 := @parameter0: byte;

        l1 := @parameter1: int;

        l2 := @parameter2: boolean;

        if l2 == 0 goto label1;

        $stack4 = staticinvoke <cck.util.Arithmetic: byte setBit(byte,int)>(l0, l1);

        return $stack4;

     label1:
        $stack3 = staticinvoke <cck.util.Arithmetic: byte clearBit(byte,int)>(l0, l1);

        return $stack3;
    }

    public static int setBit(int, int, boolean)
    {
        int l1, l3, l0, $stack5, l4#1;
        boolean l2;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        l2 := @parameter2: boolean;

        l3 = 1 << l1;

        if l2 == 0 goto label1;

        l4#1 = l0 | l3;

        goto label2;

     label1:
        $stack5 = l3 ^ -1;

        l4#1 = l0 & $stack5;

     label2:
        return l4#1;
    }

    public static long setBit(long, int, boolean)
    {
        int l2;
        long l4, l0, $stack8, l6#1;
        boolean l3;

        l0 := @parameter0: long;

        l2 := @parameter1: int;

        l3 := @parameter2: boolean;

        l4 = 1L << l2;

        if l3 == 0 goto label1;

        l6#1 = l0 | l4;

        goto label2;

     label1:
        $stack8 = l4 ^ -1L;

        l6#1 = l0 & $stack8;

     label2:
        return l6#1;
    }

    public static int signExtend(int, int)
    {
        int l0, l1, $stack3, $stack4;
        boolean $stack2;

        l0 := @parameter0: int;

        l1 := @parameter1: int;

        $stack2 = staticinvoke <cck.util.Arithmetic: boolean getBit(int,int)>(l0, l1);

        if $stack2 == 0 goto label1;

        $stack3 = -1 << l1;

        $stack4 = l0 | $stack3;

        return $stack4;

     label1:
        return l0;
    }

    public static char ubyte(byte)
    {
        byte l0;
        int $stack1;
        char $stack2;

        l0 := @parameter0: byte;

        $stack1 = l0 & 255;

        $stack2 = (char) $stack1;

        return $stack2;
    }

    public static char uhigh(char)
    {
        char l0, $stack2;
        int $stack1;

        l0 := @parameter0: char;

        $stack1 = l0 >> 8;

        $stack2 = (char) $stack1;

        return $stack2;
    }

    public static char uhigh(short)
    {
        short l0;
        int $stack1, $stack2;
        char $stack3;

        l0 := @parameter0: short;

        $stack1 = l0 & 65280;

        $stack2 = $stack1 >> 8;

        $stack3 = (char) $stack2;

        return $stack3;
    }

    public static char ulow(char)
    {
        char l0, $stack2;
        int $stack1;

        l0 := @parameter0: char;

        $stack1 = l0 & 255;

        $stack2 = (char) $stack1;

        return $stack2;
    }

    public static char ulow(short)
    {
        short l0;
        int $stack1;
        char $stack2;

        l0 := @parameter0: short;

        $stack1 = l0 & 255;

        $stack2 = (char) $stack1;

        return $stack2;
    }

    public static char uword(byte, byte)
    {
        byte l0, l1;
        int $stack2, $stack3, $stack4, $stack5;
        char $stack6;

        l0 := @parameter0: byte;

        l1 := @parameter1: byte;

        $stack4 = l0 & 255;

        $stack2 = l1 & 255;

        $stack3 = $stack2 << 8;

        $stack5 = $stack4 | $stack3;

        $stack6 = (char) $stack5;

        return $stack6;
    }

    public static short word(byte, byte)
    {
        byte l0, l1;
        int $stack2, $stack3, $stack4;
        short $stack5;

        l0 := @parameter0: byte;

        l1 := @parameter1: byte;

        $stack3 = l0 & 255;

        $stack2 = l1 << 8;

        $stack4 = $stack3 | $stack2;

        $stack5 = (short) $stack4;

        return $stack5;
    }
}
