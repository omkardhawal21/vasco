public class cck.elf.ELFHeader extends java.lang.Object
{
    protected static final int ELFCLASSNONE;
    protected static final int ELFCLASS32;
    protected static final int ELFCLASS64;
    protected static final int ELFCLASSNUM;
    protected static final int EI_NIDENT;
    protected static final int EI_CLASS;
    protected static final int EI_DATA;
    protected static final int EI_VERSION;
    protected static final int EI_PAD;
    protected static final int ELFDATA2LSB;
    protected static final int ELFDATA2MSB;
    public final byte[] e_ident;
    public short e_type;
    public short e_machine;
    public int e_version;
    public int e_entry;
    public int e_phoff;
    public int e_shoff;
    public int e_flags;
    public short e_ehsize;
    public short e_phentsize;
    public short e_phnum;
    public short e_shentsize;
    public short e_shnum;
    public short e_shstrndx;
    boolean bigEndian;

    public void <init>()
    {
        cck.elf.ELFHeader l0;
        byte[] $stack1;

        l0 := @this: cck.elf.ELFHeader;

        specialinvoke l0.<java.lang.Object: void <init>()>();

        $stack1 = newarray (byte)[16];

        l0.<cck.elf.ELFHeader: byte[] e_ident> = $stack1;

        return;
    }

    private void checkIdent() throws cck.elf.ELFHeader$FormatError
    {
        cck.elf.ELFHeader l0;
        boolean $stack1;

        l0 := @this: cck.elf.ELFHeader;

        specialinvoke l0.<cck.elf.ELFHeader: void checkIndentByte(int,int)>(0, 127);

        specialinvoke l0.<cck.elf.ELFHeader: void checkIndentByte(int,int)>(1, 69);

        specialinvoke l0.<cck.elf.ELFHeader: void checkIndentByte(int,int)>(2, 76);

        specialinvoke l0.<cck.elf.ELFHeader: void checkIndentByte(int,int)>(3, 70);

        $stack1 = virtualinvoke l0.<cck.elf.ELFHeader: boolean isBigEndian()>();

        l0.<cck.elf.ELFHeader: boolean bigEndian> = $stack1;

        return;
    }

    private void checkIndentByte(int, int) throws cck.elf.ELFHeader$FormatError
    {
        cck.elf.ELFHeader l0;
        int l1, l2;
        byte[] $stack3;
        byte $stack4;
        cck.elf.ELFHeader$FormatError $stack5;

        l0 := @this: cck.elf.ELFHeader;

        l1 := @parameter0: int;

        l2 := @parameter1: int;

        $stack3 = l0.<cck.elf.ELFHeader: byte[] e_ident>;

        $stack4 = $stack3[l1];

        if $stack4 == l2 goto label1;

        $stack5 = new cck.elf.ELFHeader$FormatError;

        specialinvoke $stack5.<cck.elf.ELFHeader$FormatError: void <init>(cck.elf.ELFHeader)>(l0);

        throw $stack5;

     label1:
        return;
    }

    public java.lang.String getArchitecture()
    {
        cck.elf.ELFHeader l0;
        short $stack1;
        java.lang.String $stack2;

        l0 := @this: cck.elf.ELFHeader;

        $stack1 = l0.<cck.elf.ELFHeader: short e_machine>;

        $stack2 = staticinvoke <cck.elf.ELFIdentifier: java.lang.String getArchitecture(int)>($stack1);

        return $stack2;
    }

    public int getVersion()
    {
        cck.elf.ELFHeader l0;
        byte[] $stack1;
        byte $stack2;

        l0 := @this: cck.elf.ELFHeader;

        $stack1 = l0.<cck.elf.ELFHeader: byte[] e_ident>;

        $stack2 = $stack1[6];

        return $stack2;
    }

    public boolean is32Bit()
    {
        byte[] $stack1;
        byte $stack2;
        cck.elf.ELFHeader l0#1;
        boolean l0#2;

        l0#1 := @this: cck.elf.ELFHeader;

        $stack1 = l0#1.<cck.elf.ELFHeader: byte[] e_ident>;

        $stack2 = $stack1[4];

        if $stack2 != 1 goto label1;

        l0#2 = 1;

        goto label2;

     label1:
        l0#2 = 0;

     label2:
        return l0#2;
    }

    public boolean is64Bit()
    {
        byte[] $stack1;
        byte $stack2;
        cck.elf.ELFHeader l0#1;
        boolean l0#2;

        l0#1 := @this: cck.elf.ELFHeader;

        $stack1 = l0#1.<cck.elf.ELFHeader: byte[] e_ident>;

        $stack2 = $stack1[4];

        if $stack2 != 2 goto label1;

        l0#2 = 1;

        goto label2;

     label1:
        l0#2 = 0;

     label2:
        return l0#2;
    }

    public boolean isBigEndian()
    {
        byte[] $stack1;
        byte $stack2;
        cck.elf.ELFHeader l0#1;
        boolean l0#2;

        l0#1 := @this: cck.elf.ELFHeader;

        $stack1 = l0#1.<cck.elf.ELFHeader: byte[] e_ident>;

        $stack2 = $stack1[6];

        if $stack2 != 2 goto label1;

        l0#2 = 1;

        goto label2;

     label1:
        l0#2 = 0;

     label2:
        return l0#2;
    }

    public boolean isLittleEndian()
    {
        byte[] $stack1;
        byte $stack2;
        cck.elf.ELFHeader l0#1;
        boolean l0#2;

        l0#1 := @this: cck.elf.ELFHeader;

        $stack1 = l0#1.<cck.elf.ELFHeader: byte[] e_ident>;

        $stack2 = $stack1[6];

        if $stack2 != 1 goto label1;

        l0#2 = 1;

        goto label2;

     label1:
        l0#2 = 0;

     label2:
        return l0#2;
    }

    public void read(java.io.RandomAccessFile) throws java.io.IOException, cck.elf.ELFHeader$FormatError
    {
        java.io.RandomAccessFile l1;
        long $stack3;
        byte $stack4;
        cck.elf.ELFHeader l0;
        short $stack5, $stack6, $stack12, $stack13, $stack14, $stack15, $stack16, $stack17;
        int $stack7, $stack8, $stack9, $stack10, $stack11, $stack18, $stack20, l2#1;
        byte[] $stack19;
        cck.elf.ELFHeader$FormatError $stack23;
        cck.elf.ELFDataInputStream l2#2;

        l0 := @this: cck.elf.ELFHeader;

        l1 := @parameter0: java.io.RandomAccessFile;

        $stack3 = virtualinvoke l1.<java.io.RandomAccessFile: long length()>();

        $stack4 = $stack3 cmp 16L;

        if $stack4 >= 0 goto label1;

        $stack23 = new cck.elf.ELFHeader$FormatError;

        specialinvoke $stack23.<cck.elf.ELFHeader$FormatError: void <init>(cck.elf.ELFHeader)>(l0);

        throw $stack23;

     label1:
        l2#1 = 0;

     label2:
        if l2#1 >= 16 goto label3;

        $stack19 = l0.<cck.elf.ELFHeader: byte[] e_ident>;

        $stack18 = 16 - l2#1;

        $stack20 = virtualinvoke l1.<java.io.RandomAccessFile: int read(byte[],int,int)>($stack19, l2#1, $stack18);

        l2#1 = l2#1 + $stack20;

        goto label2;

     label3:
        specialinvoke l0.<cck.elf.ELFHeader: void checkIdent()>();

        l2#2 = new cck.elf.ELFDataInputStream;

        specialinvoke l2#2.<cck.elf.ELFDataInputStream: void <init>(cck.elf.ELFHeader,java.io.RandomAccessFile)>(l0, l1);

        $stack5 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: short read_Elf32_Half()>();

        l0.<cck.elf.ELFHeader: short e_type> = $stack5;

        $stack6 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: short read_Elf32_Half()>();

        l0.<cck.elf.ELFHeader: short e_machine> = $stack6;

        $stack7 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: int read_Elf32_Word()>();

        l0.<cck.elf.ELFHeader: int e_version> = $stack7;

        $stack8 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: int read_Elf32_Addr()>();

        l0.<cck.elf.ELFHeader: int e_entry> = $stack8;

        $stack9 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: int read_Elf32_Off()>();

        l0.<cck.elf.ELFHeader: int e_phoff> = $stack9;

        $stack10 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: int read_Elf32_Off()>();

        l0.<cck.elf.ELFHeader: int e_shoff> = $stack10;

        $stack11 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: int read_Elf32_Word()>();

        l0.<cck.elf.ELFHeader: int e_flags> = $stack11;

        $stack12 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: short read_Elf32_Half()>();

        l0.<cck.elf.ELFHeader: short e_ehsize> = $stack12;

        $stack13 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: short read_Elf32_Half()>();

        l0.<cck.elf.ELFHeader: short e_phentsize> = $stack13;

        $stack14 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: short read_Elf32_Half()>();

        l0.<cck.elf.ELFHeader: short e_phnum> = $stack14;

        $stack15 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: short read_Elf32_Half()>();

        l0.<cck.elf.ELFHeader: short e_shentsize> = $stack15;

        $stack16 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: short read_Elf32_Half()>();

        l0.<cck.elf.ELFHeader: short e_shnum> = $stack16;

        $stack17 = virtualinvoke l2#2.<cck.elf.ELFDataInputStream: short read_Elf32_Half()>();

        l0.<cck.elf.ELFHeader: short e_shstrndx> = $stack17;

        return;
    }

    public static void <clinit>()
    {
        <cck.elf.ELFHeader: int ELFDATA2MSB> = 2;

        <cck.elf.ELFHeader: int ELFDATA2LSB> = 1;

        <cck.elf.ELFHeader: int EI_PAD> = 7;

        <cck.elf.ELFHeader: int EI_VERSION> = 6;

        <cck.elf.ELFHeader: int EI_DATA> = 5;

        <cck.elf.ELFHeader: int EI_CLASS> = 4;

        <cck.elf.ELFHeader: int EI_NIDENT> = 16;

        <cck.elf.ELFHeader: int ELFCLASSNUM> = 3;

        <cck.elf.ELFHeader: int ELFCLASS64> = 2;

        <cck.elf.ELFHeader: int ELFCLASS32> = 1;

        <cck.elf.ELFHeader: int ELFCLASSNONE> = 0;

        return;
    }
}
