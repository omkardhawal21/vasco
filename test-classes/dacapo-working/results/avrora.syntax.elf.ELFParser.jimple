public class avrora.syntax.elf.ELFParser extends avrora.core.ProgramReader
{
    cck.elf.ELFHeader header;
    cck.elf.ELFProgramHeaderTable pht;
    cck.elf.ELFSectionHeaderTable sht;
    java.util.List symbolTables;
    cck.elf.ELFStringTable shstrtab;
    avrora.arch.AbstractArchitecture arch;
    protected final cck.util.Option$Bool SYMBOLS;

    public void <init>()
    {
        avrora.syntax.elf.ELFParser l0;
        cck.util.Option$Bool $stack1;

        l0 := @this: avrora.syntax.elf.ELFParser;

        specialinvoke l0.<avrora.core.ProgramReader: void <init>(java.lang.String)>("The \"elf\" format loader reads a program from an ELF (Executable and Linkable Format) as a binary and disassembles the sections corresponding to executable code.");

        $stack1 = virtualinvoke l0.<avrora.syntax.elf.ELFParser: cck.util.Option$Bool newOption(java.lang.String,boolean,java.lang.String)>("load-symbols", 1, "This option causes the ELF loader to load the symbol table (if it exists) from the ELF file. The symbol table contains information about the names and sizes of data items and functions within the executable. Enabling this option allows for more source-level information during simulation, but disabling it speeds up loading of ELF files.");

        l0.<avrora.syntax.elf.ELFParser: cck.util.Option$Bool SYMBOLS> = $stack1;

        return;
    }

    private void addSymbols(avrora.core.SourceMapping, cck.elf.ELFSymbolTable, cck.elf.ELFStringTable)
    {
        cck.elf.ELFSymbolTable l2;
        cck.elf.ELFSymbolTable$Entry[] $stack6, $stack8;
        int $stack7, $stack13, $stack15, $stack16, $stack17, l5#1;
        cck.elf.ELFSymbolTable$Entry l4;
        boolean $stack9, $stack20;
        avrora.core.SourceMapping l1;
        avrora.syntax.elf.ELFParser l0;
        short $stack10;
        cck.elf.ELFSectionHeaderTable $stack11;
        java.lang.String $stack12, $stack14;
        cck.elf.ELFStringTable l3;

        l0 := @this: avrora.syntax.elf.ELFParser;

        l1 := @parameter0: avrora.core.SourceMapping;

        l2 := @parameter1: cck.elf.ELFSymbolTable;

        l3 := @parameter2: cck.elf.ELFStringTable;

        l5#1 = 0;

     label1:
        $stack6 = l2.<cck.elf.ELFSymbolTable: cck.elf.ELFSymbolTable$Entry[] entries>;

        $stack7 = lengthof $stack6;

        if l5#1 >= $stack7 goto label4;

        $stack8 = l2.<cck.elf.ELFSymbolTable: cck.elf.ELFSymbolTable$Entry[] entries>;

        l4 = $stack8[l5#1];

        $stack9 = virtualinvoke l4.<cck.elf.ELFSymbolTable$Entry: boolean isFunction()>();

        if $stack9 != 0 goto label2;

        $stack20 = virtualinvoke l4.<cck.elf.ELFSymbolTable$Entry: boolean isObject()>();

        if $stack20 == 0 goto label3;

     label2:
        $stack11 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFSectionHeaderTable sht>;

        $stack10 = l4.<cck.elf.ELFSymbolTable$Entry: short st_shndx>;

        $stack12 = virtualinvoke $stack11.<cck.elf.ELFSectionHeaderTable: java.lang.String getSectionName(int)>($stack10);

        $stack13 = l4.<cck.elf.ELFSymbolTable$Entry: int st_name>;

        $stack14 = staticinvoke <avrora.actions.ELFDumpAction: java.lang.String getName(cck.elf.ELFStringTable,int)>(l3, $stack13);

        $stack15 = l4.<cck.elf.ELFSymbolTable$Entry: int st_value>;

        $stack16 = specialinvoke l0.<avrora.syntax.elf.ELFParser: int findLMA(cck.elf.ELFSymbolTable$Entry)>(l4);

        $stack17 = l4.<cck.elf.ELFSymbolTable$Entry: int st_size>;

        virtualinvoke l1.<avrora.core.SourceMapping: void newLocation(java.lang.String,java.lang.String,int,int,int)>($stack12, $stack14, $stack15, $stack16, $stack17);

     label3:
        l5#1 = l5#1 + 1;

        goto label1;

     label4:
        return;
    }

    private avrora.core.Program createProgram()
    {
        avrora.syntax.elf.ELFParser l0;
        cck.elf.ELFProgramHeaderTable $stack6, $stack11;
        cck.elf.ELFProgramHeaderTable$Entry32[] $stack7, $stack12;
        int $stack8, $stack16, l2, $stack17, l3#1, l4#2, l5#3, l1#5;
        avrora.core.Program $stack9;
        avrora.arch.AbstractArchitecture $stack10;
        boolean $stack13;
        cck.elf.ELFProgramHeaderTable$Entry32 l1#4;

        l0 := @this: avrora.syntax.elf.ELFParser;

        l3#1 = 2147483647;

        l4#2 = 0;

        l5#3 = 0;

     label1:
        $stack6 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFProgramHeaderTable pht>;

        $stack7 = $stack6.<cck.elf.ELFProgramHeaderTable: cck.elf.ELFProgramHeaderTable$Entry32[] entries>;

        $stack8 = lengthof $stack7;

        if l5#3 >= $stack8 goto label4;

        $stack11 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFProgramHeaderTable pht>;

        $stack12 = $stack11.<cck.elf.ELFProgramHeaderTable: cck.elf.ELFProgramHeaderTable$Entry32[] entries>;

        l1#4 = $stack12[l5#3];

        $stack13 = virtualinvoke l1#4.<cck.elf.ELFProgramHeaderTable$Entry32: boolean isLoadable()>();

        if $stack13 == 0 goto label3;

        $stack16 = l1#4.<cck.elf.ELFProgramHeaderTable$Entry32: int p_filesz>;

        if $stack16 <= 0 goto label3;

        l2 = l1#4.<cck.elf.ELFProgramHeaderTable$Entry32: int p_paddr>;

        $stack17 = l1#4.<cck.elf.ELFProgramHeaderTable$Entry32: int p_filesz>;

        l1#5 = l2 + $stack17;

        if l2 >= l3#1 goto label2;

        l3#1 = l2;

     label2:
        if l1#5 <= l4#2 goto label3;

        l4#2 = l1#5;

     label3:
        l5#3 = l5#3 + 1;

        goto label1;

     label4:
        $stack9 = new avrora.core.Program;

        $stack10 = l0.<avrora.syntax.elf.ELFParser: avrora.arch.AbstractArchitecture arch>;

        specialinvoke $stack9.<avrora.core.Program: void <init>(avrora.arch.AbstractArchitecture,int,int)>($stack10, l3#1, l4#2);

        return $stack9;
    }

    private void disassembleSection(byte[], cck.elf.ELFProgramHeaderTable$Entry32, avrora.core.Program)
    {
        avrora.arch.AbstractArchitecture $stack6;
        avrora.arch.AbstractDisassembler $stack7;
        byte[] l1;
        int $stack8, $stack9, $stack13, $stack14, l5#3;
        cck.elf.ELFProgramHeaderTable$Entry32 l2;
        avrora.arch.AbstractInstr $stack10;
        avrora.core.Program l3;
        avrora.syntax.elf.ELFParser l0#1;

        l0#1 := @this: avrora.syntax.elf.ELFParser;

        l1 := @parameter0: byte[];

        l2 := @parameter1: cck.elf.ELFProgramHeaderTable$Entry32;

        l3 := @parameter2: avrora.core.Program;

        $stack6 = l0#1.<avrora.syntax.elf.ELFParser: avrora.arch.AbstractArchitecture arch>;

        $stack7 = interfaceinvoke $stack6.<avrora.arch.AbstractArchitecture: avrora.arch.AbstractDisassembler getDisassembler()>();

        l5#3 = 0;

     label1:
        $stack8 = lengthof l1;

        if l5#3 >= $stack8 goto label3;

        $stack9 = l2.<cck.elf.ELFProgramHeaderTable$Entry32: int p_paddr>;

        $stack10 = interfaceinvoke $stack7.<avrora.arch.AbstractDisassembler: avrora.arch.AbstractInstr disassemble(int,int,byte[])>($stack9, l5#3, l1);

        if $stack10 == null goto label2;

        $stack13 = l2.<cck.elf.ELFProgramHeaderTable$Entry32: int p_paddr>;

        $stack14 = $stack13 + l5#3;

        virtualinvoke l3.<avrora.core.Program: void writeInstr(avrora.arch.AbstractInstr,int)>($stack10, $stack14);

     label2:
        l5#3 = l5#3 + 2;

        goto label1;

     label3:
        return;
    }

    private int findLMA(cck.elf.ELFSymbolTable$Entry)
    {
        avrora.syntax.elf.ELFParser l0;
        cck.elf.ELFSectionHeaderTable $stack4;
        cck.elf.ELFSymbolTable$Entry l1;
        short $stack5;
        cck.elf.ELFSectionHeaderTable$Entry32[] $stack6;
        cck.elf.ELFSectionHeaderTable$Entry32 $stack7;
        int l2, $stack10, $stack14, $stack17, $stack21, $stack22, $stack23, l3#1;
        cck.elf.ELFProgramHeaderTable $stack8, $stack11, $stack18;
        cck.elf.ELFProgramHeaderTable$Entry32[] $stack9, $stack12, $stack19;
        cck.elf.ELFProgramHeaderTable$Entry32 $stack13, $stack20;

        l0 := @this: avrora.syntax.elf.ELFParser;

        l1 := @parameter0: cck.elf.ELFSymbolTable$Entry;

        $stack4 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFSectionHeaderTable sht>;

        $stack6 = $stack4.<cck.elf.ELFSectionHeaderTable: cck.elf.ELFSectionHeaderTable$Entry32[] entries>;

        $stack5 = l1.<cck.elf.ELFSymbolTable$Entry: short st_shndx>;

        $stack7 = $stack6[$stack5];

        l2 = $stack7.<cck.elf.ELFSectionHeaderTable$Entry32: int sh_addr>;

        l3#1 = 0;

     label1:
        $stack8 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFProgramHeaderTable pht>;

        $stack9 = $stack8.<cck.elf.ELFProgramHeaderTable: cck.elf.ELFProgramHeaderTable$Entry32[] entries>;

        $stack10 = lengthof $stack9;

        if l3#1 >= $stack10 goto label3;

        $stack11 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFProgramHeaderTable pht>;

        $stack12 = $stack11.<cck.elf.ELFProgramHeaderTable: cck.elf.ELFProgramHeaderTable$Entry32[] entries>;

        $stack13 = $stack12[l3#1];

        $stack14 = $stack13.<cck.elf.ELFProgramHeaderTable$Entry32: int p_vaddr>;

        if $stack14 != l2 goto label2;

        $stack17 = l1.<cck.elf.ELFSymbolTable$Entry: int st_value>;

        $stack22 = $stack17 - l2;

        $stack18 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFProgramHeaderTable pht>;

        $stack19 = $stack18.<cck.elf.ELFProgramHeaderTable: cck.elf.ELFProgramHeaderTable$Entry32[] entries>;

        $stack20 = $stack19[l3#1];

        $stack21 = $stack20.<cck.elf.ELFProgramHeaderTable$Entry32: int p_paddr>;

        $stack23 = $stack22 + $stack21;

        return $stack23;

     label2:
        l3#1 = l3#1 + 1;

        goto label1;

     label3:
        return 0;
    }

    public avrora.arch.AbstractArchitecture getArchitecture()
    {
        cck.util.Option$Str $stack3;
        java.lang.String $stack4, $stack6, $stack8, $stack15, $stack18, $stack20;
        cck.elf.ELFHeader $stack5;
        avrora.arch.AbstractArchitecture $stack7, $stack10;
        boolean $stack9;
        java.lang.StringBuilder $stack12, $stack14, $stack16, $stack17, $stack19;
        avrora.syntax.elf.ELFParser l0#1;

        l0#1 := @this: avrora.syntax.elf.ELFParser;

        $stack3 = l0#1.<avrora.syntax.elf.ELFParser: cck.util.Option$Str ARCH>;

        $stack4 = virtualinvoke $stack3.<cck.util.Option$Str: java.lang.String get()>();

        $stack5 = l0#1.<avrora.syntax.elf.ELFParser: cck.elf.ELFHeader header>;

        $stack6 = virtualinvoke $stack5.<cck.elf.ELFHeader: java.lang.String getArchitecture()>();

        $stack7 = staticinvoke <avrora.arch.ArchitectureRegistry: avrora.arch.AbstractArchitecture getArchitecture(java.lang.String)>($stack6);

        $stack8 = "";

        $stack9 = virtualinvoke $stack8.<java.lang.String: boolean equals(java.lang.Object)>($stack4);

        if $stack9 != 0 goto label1;

        $stack10 = staticinvoke <avrora.arch.ArchitectureRegistry: avrora.arch.AbstractArchitecture getArchitecture(java.lang.String)>($stack4);

        if $stack7 == $stack10 goto label1;

        $stack12 = new java.lang.StringBuilder;

        specialinvoke $stack12.<java.lang.StringBuilder: void <init>()>();

        $stack14 = virtualinvoke $stack12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("expected ");

        $stack15 = staticinvoke <cck.text.StringUtil: java.lang.String quote(java.lang.Object)>($stack4);

        $stack16 = virtualinvoke $stack14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack15);

        $stack17 = virtualinvoke $stack16.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" architecture, but header reports ");

        $stack18 = staticinvoke <cck.text.StringUtil: java.lang.String quote(java.lang.Object)>($stack6);

        $stack19 = virtualinvoke $stack17.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack18);

        $stack20 = virtualinvoke $stack19.<java.lang.StringBuilder: java.lang.String toString()>();

        staticinvoke <cck.util.Util: void userError(java.lang.String,java.lang.String)>("ELF Error", $stack20);

     label1:
        return $stack7;
    }

    private avrora.core.Program loadSections(java.io.RandomAccessFile) throws java.io.IOException
    {
        cck.elf.ELFDataInputStream l2;
        avrora.syntax.elf.ELFParser l0;
        java.io.RandomAccessFile l1;
        cck.elf.ELFHeader $stack7;
        avrora.core.Program $stack8;
        cck.elf.ELFProgramHeaderTable $stack9, $stack12;
        cck.elf.ELFProgramHeaderTable$Entry32[] $stack10, $stack13;
        int $stack11, $stack17, $stack18, $stack20, $stack21, $stack23, l6#1;
        cck.elf.ELFProgramHeaderTable$Entry32 l4;
        boolean $stack14, $stack24;
        long $stack19;
        byte[] $stack22;

        l0 := @this: avrora.syntax.elf.ELFParser;

        l1 := @parameter0: java.io.RandomAccessFile;

        l2 = new cck.elf.ELFDataInputStream;

        $stack7 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFHeader header>;

        specialinvoke l2.<cck.elf.ELFDataInputStream: void <init>(cck.elf.ELFHeader,java.io.RandomAccessFile)>($stack7, l1);

        $stack8 = specialinvoke l0.<avrora.syntax.elf.ELFParser: avrora.core.Program createProgram()>();

        l6#1 = 0;

     label1:
        $stack9 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFProgramHeaderTable pht>;

        $stack10 = $stack9.<cck.elf.ELFProgramHeaderTable: cck.elf.ELFProgramHeaderTable$Entry32[] entries>;

        $stack11 = lengthof $stack10;

        if l6#1 >= $stack11 goto label3;

        $stack12 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFProgramHeaderTable pht>;

        $stack13 = $stack12.<cck.elf.ELFProgramHeaderTable: cck.elf.ELFProgramHeaderTable$Entry32[] entries>;

        l4 = $stack13[l6#1];

        $stack14 = virtualinvoke l4.<cck.elf.ELFProgramHeaderTable$Entry32: boolean isLoadable()>();

        if $stack14 == 0 goto label2;

        $stack17 = l4.<cck.elf.ELFProgramHeaderTable$Entry32: int p_filesz>;

        if $stack17 <= 0 goto label2;

        $stack18 = l4.<cck.elf.ELFProgramHeaderTable$Entry32: int p_offset>;

        $stack19 = (long) $stack18;

        virtualinvoke l1.<java.io.RandomAccessFile: void seek(long)>($stack19);

        $stack21 = l4.<cck.elf.ELFProgramHeaderTable$Entry32: int p_offset>;

        $stack20 = l4.<cck.elf.ELFProgramHeaderTable$Entry32: int p_filesz>;

        $stack22 = virtualinvoke l2.<cck.elf.ELFDataInputStream: byte[] read_section(int,int)>($stack21, $stack20);

        $stack23 = l4.<cck.elf.ELFProgramHeaderTable$Entry32: int p_paddr>;

        virtualinvoke $stack8.<avrora.core.Program: void writeProgramBytes(byte[],int)>($stack22, $stack23);

        $stack24 = virtualinvoke l4.<cck.elf.ELFProgramHeaderTable$Entry32: boolean isExecutable()>();

        if $stack24 == 0 goto label2;

        specialinvoke l0.<avrora.syntax.elf.ELFParser: void disassembleSection(byte[],cck.elf.ELFProgramHeaderTable$Entry32,avrora.core.Program)>($stack22, l4, $stack8);

     label2:
        l6#1 = l6#1 + 1;

        goto label1;

     label3:
        return $stack8;
    }

    private void loadSymbolTables(avrora.core.Program, java.io.RandomAccessFile) throws java.io.IOException
    {
        avrora.core.SourceMapping l3;
        avrora.syntax.elf.ELFParser l0;
        cck.util.Option$Bool $stack4;
        boolean $stack5, $stack11;
        java.io.RandomAccessFile l2;
        cck.elf.ELFSectionHeaderTable $stack6;
        cck.elf.ELFHeader $stack7;
        java.util.List $stack8, $stack9;
        java.util.Iterator $stack10;
        java.lang.Object $stack12;
        cck.elf.ELFSymbolTable $stack13;
        cck.elf.ELFStringTable $stack14;
        avrora.core.Program l1#1;

        l0 := @this: avrora.syntax.elf.ELFParser;

        l1#1 := @parameter0: avrora.core.Program;

        l2 := @parameter1: java.io.RandomAccessFile;

        l3 = new avrora.core.SourceMapping;

        specialinvoke l3.<avrora.core.SourceMapping: void <init>(avrora.core.Program)>(l1#1);

        virtualinvoke l1#1.<avrora.core.Program: void setSourceMapping(avrora.core.SourceMapping)>(l3);

        $stack4 = l0.<avrora.syntax.elf.ELFParser: cck.util.Option$Bool SYMBOLS>;

        $stack5 = virtualinvoke $stack4.<cck.util.Option$Bool: boolean get()>();

        if $stack5 == 0 goto label2;

        $stack7 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFHeader header>;

        $stack6 = l0.<avrora.syntax.elf.ELFParser: cck.elf.ELFSectionHeaderTable sht>;

        $stack8 = staticinvoke <cck.elf.ELFLoader: java.util.List readSymbolTables(java.io.RandomAccessFile,cck.elf.ELFHeader,cck.elf.ELFSectionHeaderTable)>(l2, $stack7, $stack6);

        l0.<avrora.syntax.elf.ELFParser: java.util.List symbolTables> = $stack8;

        $stack9 = l0.<avrora.syntax.elf.ELFParser: java.util.List symbolTables>;

        $stack10 = interfaceinvoke $stack9.<java.util.List: java.util.Iterator iterator()>();

     label1:
        $stack11 = interfaceinvoke $stack10.<java.util.Iterator: boolean hasNext()>();

        if $stack11 == 0 goto label2;

        $stack12 = interfaceinvoke $stack10.<java.util.Iterator: java.lang.Object next()>();

        $stack13 = (cck.elf.ELFSymbolTable) $stack12;

        $stack14 = virtualinvoke $stack13.<cck.elf.ELFSymbolTable: cck.elf.ELFStringTable getStringTable()>();

        specialinvoke l0.<avrora.syntax.elf.ELFParser: void addSymbols(avrora.core.SourceMapping,cck.elf.ELFSymbolTable,cck.elf.ELFStringTable)>(l3, $stack13, $stack14);

        goto label1;

     label2:
        return;
    }

    public avrora.core.Program read(java.lang.String[]) throws java.lang.Exception
    {
        int $stack4, $stack5;
        cck.elf.ELFHeader $stack6, $stack8, $stack14;
        avrora.arch.AbstractArchitecture $stack7;
        cck.elf.ELFProgramHeaderTable $stack9;
        cck.util.Option$Bool $stack10;
        boolean $stack11;
        avrora.core.Program $stack12;
        cck.elf.ELFSectionHeaderTable $stack15, $stack16;
        cck.elf.ELFStringTable $stack17;
        java.lang.String $stack25;
        java.io.RandomAccessFile $stack27;
        cck.elf.ELFHeader$FormatError $stack35;
        avrora.syntax.elf.ELFParser l0#1;
        java.lang.String[] l1#2;

        l0#1 := @this: avrora.syntax.elf.ELFParser;

        l1#2 := @parameter0: java.lang.String[];

        $stack4 = lengthof l1#2;

        if $stack4 != 0 goto label1;

        staticinvoke <cck.util.Util: void userError(java.lang.String)>("no input files");

     label1:
        $stack5 = lengthof l1#2;

        if $stack5 == 1 goto label2;

        staticinvoke <cck.util.Util: void userError(java.lang.String)>("input type \"elf\" accepts only one file at a time.");

     label2:
        $stack25 = l1#2[0];

        staticinvoke <avrora.Main: void checkFileExists(java.lang.String)>($stack25);

        $stack27 = new java.io.RandomAccessFile;

        specialinvoke $stack27.<java.io.RandomAccessFile: void <init>(java.lang.String,java.lang.String)>($stack25, "r");

     label3:
        $stack6 = staticinvoke <cck.elf.ELFLoader: cck.elf.ELFHeader readELFHeader(java.io.RandomAccessFile)>($stack27);

        l0#1.<avrora.syntax.elf.ELFParser: cck.elf.ELFHeader header> = $stack6;

     label4:
        goto label6;

     label5:
        $stack35 := @caughtexception;

        staticinvoke <cck.util.Util: void userError(java.lang.String,java.lang.String)>($stack25, "invalid ELF header");

     label6:
        $stack7 = virtualinvoke l0#1.<avrora.syntax.elf.ELFParser: avrora.arch.AbstractArchitecture getArchitecture()>();

        l0#1.<avrora.syntax.elf.ELFParser: avrora.arch.AbstractArchitecture arch> = $stack7;

        $stack8 = l0#1.<avrora.syntax.elf.ELFParser: cck.elf.ELFHeader header>;

        $stack9 = staticinvoke <cck.elf.ELFLoader: cck.elf.ELFProgramHeaderTable readPHT(java.io.RandomAccessFile,cck.elf.ELFHeader)>($stack27, $stack8);

        l0#1.<avrora.syntax.elf.ELFParser: cck.elf.ELFProgramHeaderTable pht> = $stack9;

        $stack10 = l0#1.<avrora.syntax.elf.ELFParser: cck.util.Option$Bool SYMBOLS>;

        $stack11 = virtualinvoke $stack10.<cck.util.Option$Bool: boolean get()>();

        if $stack11 == 0 goto label7;

        $stack14 = l0#1.<avrora.syntax.elf.ELFParser: cck.elf.ELFHeader header>;

        $stack15 = staticinvoke <cck.elf.ELFLoader: cck.elf.ELFSectionHeaderTable readSHT(java.io.RandomAccessFile,cck.elf.ELFHeader)>($stack27, $stack14);

        l0#1.<avrora.syntax.elf.ELFParser: cck.elf.ELFSectionHeaderTable sht> = $stack15;

        $stack16 = l0#1.<avrora.syntax.elf.ELFParser: cck.elf.ELFSectionHeaderTable sht>;

        $stack17 = virtualinvoke $stack16.<cck.elf.ELFSectionHeaderTable: cck.elf.ELFStringTable getStringTable()>();

        l0#1.<avrora.syntax.elf.ELFParser: cck.elf.ELFStringTable shstrtab> = $stack17;

     label7:
        $stack12 = specialinvoke l0#1.<avrora.syntax.elf.ELFParser: avrora.core.Program loadSections(java.io.RandomAccessFile)>($stack27);

        specialinvoke l0#1.<avrora.syntax.elf.ELFParser: void loadSymbolTables(avrora.core.Program,java.io.RandomAccessFile)>($stack12, $stack27);

        return $stack12;

        catch cck.elf.ELFHeader$FormatError from label3 to label4 with label5;
    }
}
