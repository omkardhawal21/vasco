public class avrora.arch.ArchitectureRegistry extends java.lang.Object
{
    private static cck.util.ClassMap archMap;

    public void <init>()
    {
        avrora.arch.ArchitectureRegistry l0;

        l0 := @this: avrora.arch.ArchitectureRegistry;

        specialinvoke l0.<java.lang.Object: void <init>()>();

        return;
    }

    public static synchronized void addArchitectures()
    {
        cck.util.ClassMap $stack1, $stack2, $stack4, $stack6, $stack8, $stack9, $stack10;
        avrora.arch.legacy.LegacyArchitecture $stack3;
        avrora.arch.avr.AVRArchitecture $stack5;
        avrora.arch.msp430.MSP430Architecture $stack7;
        cck.help.HelpCategory l0;

        $stack1 = <avrora.arch.ArchitectureRegistry: cck.util.ClassMap archMap>;

        if $stack1 != null goto label1;

        $stack2 = new cck.util.ClassMap;

        specialinvoke $stack2.<cck.util.ClassMap: void <init>(java.lang.String,java.lang.Class)>("Architecture", class "Lavrora/arch/AbstractArchitecture;");

        <avrora.arch.ArchitectureRegistry: cck.util.ClassMap archMap> = $stack2;

        $stack4 = <avrora.arch.ArchitectureRegistry: cck.util.ClassMap archMap>;

        $stack3 = <avrora.arch.legacy.LegacyArchitecture: avrora.arch.legacy.LegacyArchitecture INSTANCE>;

        virtualinvoke $stack4.<cck.util.ClassMap: void addInstance(java.lang.String,java.lang.Object)>("avr", $stack3);

        $stack6 = <avrora.arch.ArchitectureRegistry: cck.util.ClassMap archMap>;

        $stack5 = <avrora.arch.avr.AVRArchitecture: avrora.arch.avr.AVRArchitecture INSTANCE>;

        virtualinvoke $stack6.<cck.util.ClassMap: void addInstance(java.lang.String,java.lang.Object)>("avr-new", $stack5);

        $stack8 = <avrora.arch.ArchitectureRegistry: cck.util.ClassMap archMap>;

        $stack7 = <avrora.arch.msp430.MSP430Architecture: avrora.arch.msp430.MSP430Architecture INSTANCE>;

        virtualinvoke $stack8.<cck.util.ClassMap: void addInstance(java.lang.String,java.lang.Object)>("msp430", $stack7);

        l0 = new cck.help.HelpCategory;

        specialinvoke l0.<cck.help.HelpCategory: void <init>(java.lang.String,java.lang.String)>("architectures", "Help for supported instruction set architectures.");

        $stack9 = <avrora.arch.ArchitectureRegistry: cck.util.ClassMap archMap>;

        virtualinvoke l0.<cck.help.HelpCategory: void addOptionValueSection(java.lang.String,java.lang.String,java.lang.String,cck.util.ClassMap)>("ARCHITECTURES", "When running a simulation or other program analysis tool, Avrora derives information about the CPU architecture from an internal specification. In order to select the appropriate architecture, each one is named and can be selected with command line options.", "-arch", $stack9);

        staticinvoke <avrora.Defaults: void addMainCategory(cck.help.HelpCategory)>(l0);

        $stack10 = <avrora.arch.ArchitectureRegistry: cck.util.ClassMap archMap>;

        staticinvoke <avrora.Defaults: void addSubCategories(cck.util.ClassMap)>($stack10);

     label1:
        return;
    }

    public static avrora.arch.AbstractArchitecture getArchitecture(java.lang.String)
    {
        java.lang.String l0;
        cck.util.ClassMap $stack1;
        java.lang.Object $stack2;
        avrora.arch.AbstractArchitecture $stack3;

        l0 := @parameter0: java.lang.String;

        staticinvoke <avrora.arch.ArchitectureRegistry: void addArchitectures()>();

        $stack1 = <avrora.arch.ArchitectureRegistry: cck.util.ClassMap archMap>;

        $stack2 = virtualinvoke $stack1.<cck.util.ClassMap: java.lang.Object getObjectOfClass(java.lang.String)>(l0);

        $stack3 = (avrora.arch.AbstractArchitecture) $stack2;

        return $stack3;
    }
}
